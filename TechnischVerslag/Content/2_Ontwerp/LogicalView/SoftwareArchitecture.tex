\subsection{Software architectuur}
Om de onderhoudbaarheid te verbeteren van het huidige CMS is er ook nagedacht over het opzetten van de code.
Hiervoor is er gekeken hoe de architectuur zich houd aan de verschillende SOLID principes \parencite{SOLID}. 
SOLID is een acroniem dat 5 verschillende principes in houd.
Deze principes zorgen er voor dat de code beter te onderhoudbaar is en makkelijker te begrijpen is.
SOLID bestaat uit de volgende principes:

\begin{enumerate}
    \item \textbf{Single-responsibility principle}
    Dit betekent dat een class, maar 1 verantwoordelijk mag hebben en bij definitie ook maar 1 taak.
    Als een class te veel verantwoordelijkheden heeft dan wordt het moeilijker om de code te begrijpen en aan te passen.

    \item \textbf{Open-closed principle}
    Dit houdt in als class of functie of een andere software entiteit uitgebreid moet worden dat het wordt gedaan door middel van een extentie(open) in plaats van modificatie(closed).
    Hierdoor hou je oude code intact en heb je geen risico dat je bestaande code stuk gaat vanwege de nieuwe functionaliteit die geschreven is. 
        
    \item \textbf{Liskov substitution principle} 
    Een class die afgeleid is van een base class, zou moeten vervangen kunnen worden voor  een andere instantie van die base class.
    Dit moet gedaan kunnen worden zonder de validiteit (corectness) van het programma te beïnvloeden.
    Door het gebruik van het Liskov substitution principle verhoog je de consistentiteit en de verwachte uitkomst van je progamma.

    \item \textbf{Interface segregation} 
    Een interface moet alleen de methods geven die nodig is voor de client. 
    Geen client moet geforceerd zijn om methodes te implementeren waar die geen gebruik van maakt.
    Dit uit zich vaak in plaats van grote interface gebruik meerdere kleinere interfaces.
    Deze interfaces zijn verantwoordelijk voor meer specifike usecases inplaats van generaliseerde usecases

    \item \textbf{Dependency inversion} 
    Een class of module zou niet moeten afhangen van implementaties maar van abstracties.
    Hier door verminder je de koppeling van de modules/classes, en verhoog je de code onderhoudbaarheid.
    Om aan dit principe te voldoen wordt er vaak gebruik gemaakt van dependency injection.
\end{enumerate}

\whitespace
Om de verschillende aspecten van SOLID te implementeren is er gekozen om gebruik te maken van handlers.
Hierbij heeft elke handler één taak hier bij kan je denken aan het ophalen of updaten van data.
Daarnaast wordt er ook gebruik gemaakt van een repository pattern om met de database te communiseren.
Er is gekozen om gebruik te maken van een repository pattern zodat er geen afhankelijkheid is van de database.
Een sequesnce diagram van deze architectuur is te zien in figuur \ref{fig:SequenceDiagramHandlerStructure}

% Er is gekozen om een \qw{Hanlder architectuur} te gebruiken.
% Deze architectuur stijl is gebruikt bij het Poiesz team met veel success.
% De structuur bestaat uit een controller die de request afhandeld.
% Vervolgens wordt er door een ketting van handlers de data verwerkt.
% En als laatste is er een access layer gemaakt die de database operaties afhandeld.
% in figuur \ref{fig:SequenceDiagramHandlerStructure} is een voorbeeld te zien van de dataflow van het systeem.

\begin{graphic}
    \captionsetup{type=figure}
    \caption{Sequence diagram Handler structuur}
    \includegraphics[scale=0.4]{SequenceDiagramArchitectureStructure.png}
    \label{fig:SequenceDiagramHandlerStructure}
\end{graphic}

\whitespace
De verschillende handlres zorgen er voor dat het single-responsibility na gevolgt wordt.
Omdat elke handler maar een taak heeft.
Verder worden er kleine interfaces gebruikt om aan het Interface segregation principle te volgen.
En als laatste worden de verschillende dependencies geinjecteerd (dependency injection pattern) om harde koppeling te voorkomen.
% Daarnaast wordt het open-closed principle gevolgt omdat handlers extend worden

% De handlers hebben maar 1 taak hier bij kun je denken aan de data ophalen of verwijderen uit de database.
% Omdat ze maar een taak hebben zijn ze makkelijk te begrijpen en te onderhouden.
% Verder wordt er gebruik gemaakt van dependency injection om de handlers minder coppeld te maken.

